<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Capabilities on Pony Tutorial</title>
    <link>https://tutorial.ponylang.io/capabilities.html</link>
    <description>Recent content in Capabilities on Pony Tutorial</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tutorial.ponylang.io/capabilities/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Aliasing</title>
      <link>https://tutorial.ponylang.io/capabilities/aliasing.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/aliasing.html</guid>
      <description>Aliasing means having more than one variable that points to the same object.
In most programming languages, aliasing is pretty simple. You just assign some variable to another variable, and there you go, you have an alias. The variable you assign to has the same type (or some supertype) as what&amp;rsquo;s being assigned to it, and everything is fine.
In Pony, that works for some reference capabilities, but not all.</description>
    </item>
    
    <item>
      <title>Arrow Types aka Viewpoints</title>
      <link>https://tutorial.ponylang.io/capabilities/arrow-types.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/arrow-types.html</guid>
      <description>When we talked about reference capability composition and viewpoint adaptation, we dealt with cases where we know the reference capability of the origin. However, sometimes we don&amp;rsquo;t know the precise reference capability of the origin.
When that happens, we can write a viewpoint adapted type, which we call an arrow type because we write it with an -&amp;gt;.
Using this-&amp;gt; as a viewpoint A function with a box receiver can be called with a ref receiver or a val receiver as well since those are both subtypes of box.</description>
    </item>
    
    <item>
      <title>Capability Subtyping</title>
      <link>https://tutorial.ponylang.io/capabilities/capability-subtyping.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/capability-subtyping.html</guid>
      <description>Subtyping is about substitutability. That is, if we need to supply a certain type, what other types can we substitute instead? Reference capabilities factor into this.
Simple substitution First, let&amp;rsquo;s cover substitution without worrying about ephemeral types (^) or alias types (!). The &amp;lt;: symbol means &amp;ldquo;is a subtype of&amp;rdquo; or alternatively &amp;ldquo;can be substituted for&amp;rdquo;.
 iso &amp;lt;: trn. An iso is read and write unique, and a trn is just write unique, so it&amp;rsquo;s safe to substitute an iso for a trn.</description>
    </item>
    
    <item>
      <title>Combining Capabilities</title>
      <link>https://tutorial.ponylang.io/capabilities/combining-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/combining-capabilities.html</guid>
      <description>When a field of an object is read, its reference capability depends both on the reference capability of the field and the reference capability of the origin, that is, the object the field is being read from.
This is because all the guarantees that the origin reference capability makes have to be maintained for its fields as well.
Viewpoint adaptation The process of combining origin and field capabilities is called viewpoint adaptation.</description>
    </item>
    
    <item>
      <title>Consume and Destructive Read</title>
      <link>https://tutorial.ponylang.io/capabilities/consume-and-destructive-read.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/consume-and-destructive-read.html</guid>
      <description>An important part of Pony&amp;rsquo;s capabilities is being able to say &amp;ldquo;I&amp;rsquo;m done with this thing.&amp;rdquo; We&amp;rsquo;ll cover two means of handling this situation: consuming a variable and destructive reads.
Consuming a variable Sometimes, you want to move an object from one variable to another. In other words, you don&amp;rsquo;t want to make a new name for the object, exactly, you want to move the object from some existing name to a different one.</description>
    </item>
    
    <item>
      <title>Object Capabilities</title>
      <link>https://tutorial.ponylang.io/capabilities/object-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/object-capabilities.html</guid>
      <description>Pony&amp;rsquo;s capabilities-secure type system is based on the object-capability model. That sounds complicated, but really it&amp;rsquo;s elegant and simple. The core idea is this:
 A capability is an unforgeable token that (a) designates an object and (b) gives the program the authority to perform a specific set of actions on that object.
 So what&amp;rsquo;s that token? It&amp;rsquo;s an address. A pointer. A reference. It&amp;rsquo;s just&amp;hellip; an object.</description>
    </item>
    
    <item>
      <title>Passing and Sharing References</title>
      <link>https://tutorial.ponylang.io/capabilities/passing-and-sharing.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/passing-and-sharing.html</guid>
      <description>Reference capabilities make it safe to both pass mutable data between actors and to share immutable data amongst actors. Not only that, they make it safe to do it with no copying, no locks, in fact, no runtime overhead at all.
Passing For an object to be mutable, we need to be sure that no other actor can read from or write to that object. The three mutable reference capabilities (iso, trn, and ref) all make that guarantee.</description>
    </item>
    
    <item>
      <title>Recovering Capabilities</title>
      <link>https://tutorial.ponylang.io/capabilities/recovering-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/recovering-capabilities.html</guid>
      <description>A recover expression let&amp;rsquo;s you &amp;ldquo;lift&amp;rdquo; the reference capability of the result. A mutable reference capability (iso, trn, or ref) can become any reference capability, and an immutable reference capability (val or box) can become any immutable or opaque reference capability.
Why is this useful? This most straightforward use of recover is to get an iso that you can pass to another actor. But it can be used for many other things as well, such as:</description>
    </item>
    
    <item>
      <title>Reference Capabilities</title>
      <link>https://tutorial.ponylang.io/capabilities/reference-capabilities.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/reference-capabilities.html</guid>
      <description>So if the object is the capability, what controls what we can do with the object? How do we express our access rights on that object?
In Pony, we do it with reference capabilities.
Rights are part of a capability If you open a file in UNIX and get a file descriptor back, that file descriptor is a token that designates an object - but it isn&amp;rsquo;t a capability. To be a capability, we need to open that file with some permission - some access right.</description>
    </item>
    
    <item>
      <title>Reference Capability Guarantees</title>
      <link>https://tutorial.ponylang.io/capabilities/guarantees.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/guarantees.html</guid>
      <description>Since types are guarantees, it&amp;rsquo;s useful to talk about what guarantees a reference capability makes.
What is denied We&amp;rsquo;re going to talk about reference capability guarantees in terms of what&amp;rsquo;s denied. By this, we mean: what can other variables not do when you have a variable with a certain reference capability?
We need to distinguish between the actor that contains the variable in question and other actors.
This is important because data reads and writes from other actors may occur concurrently.</description>
    </item>
    
    <item>
      <title>Trust Boundary</title>
      <link>https://tutorial.ponylang.io/capabilities/trust-boundary.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/capabilities/trust-boundary.html</guid>
      <description>We mentioned previously that the C FFI can be used to break pretty much every guarantee that Pony makes. This is because, once you&amp;rsquo;ve called into C, you are executing arbitrary machine code that can stomp memory addresses, write to anything, and generally be pretty badly behaved.
Trust boundaries When we talk about trust, we don&amp;rsquo;t mean things you trust because you think they are perfect. Instead, we mean things you have to trust in order to get things done, even though you know they are imperfect.</description>
    </item>
    
  </channel>
</rss>